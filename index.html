<!DOCTYPE html>
<html>
<head>
	<title>Space Runaway</title>

	<!-- JAVASCRIPT LINKS -->
	<script type="text/javascript" src="js/class.js"></script>
	<script type="text/javascript" src="js/setView.js"></script>

	<!-- CSS LINK -->
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body onload="startGame()">

<script>
	function startGame() {
		Game.start();
	}
	var Game = {
		levelNum : 1,
		scale : 32,
		canvas : document.createElement("canvas"),
		start : function() {
			this.canvas.width = 1280;
			this.canvas.height = 720;
			this.ctx = this.canvas.getContext("2d");
			document.body.insertBefore(this.canvas, document.body.childNodes[0]);
			// Origin
			entities.origin = new Player("",0,0);
			// Draw
			Game.draw();
			// Key handling
			window.onkeydown = this.key_down;
			window.onkeyup = this.key_up;
			// Level
			this.loadLevel(Game.levelNum);
		},
		clear : function() {
			Game.ctx.clearRect(entities.origin.x,entities.origin.y,Game.canvas.width,Game.canvas.height);
		},
		draw : function() {
			Game.clear();
			for (var i in entities) {
				if (entities[i].move!==undefined) {
					entities[i].move(Game.ctx);
					Game.ctx.drawImage(Game.canvas, 0, 0);
				}
			}
			Game.clear();
			for (var i in entities) {
				entities[i].draw(Game.ctx);
			}
			window.requestAnimationFrame(Game.draw);
		},
		// Key handling
		key_down : function(e) {
			for (var i in entities) {
				if (entities[i].keysDown!==undefined) {
					entities[i].keysDown[e.keyCode]=true;
				}
			}
		},
		key_up : function(e) {
			for (var i in entities) {
				if (entities[i].keysDown!==undefined) {
					delete entities[i].keysDown[e.keyCode];
				}
			}
		},
		// Level loading and parsing
		loadLevel : function(levelNum) {
			// Gets level from server, can't get locally
			var url = "levels/level" + levelNum + ".json";
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (xhttp.readyState == 4) {
					var json = xhttp.responseText;
					var obj = {};
					obj = JSON.parse(json);
					for (var i = 0; i < obj.board.length; i++) {
						switch (obj.board[i].type) {
							case 1:
								entities['entity'+i] = new Player("images/sprites/player.png", (obj.board[i].x*Game.scale), (obj.board[i].y*Game.scale));
								break;
							case 2:
								entities['entity'+i] = new Goblin("images/sprites/space_goblin.png", (obj.board[i].x*Game.scale), (obj.board[i].y*Game.scale));
								break;
							case 3:
								entities['entity'+i] = new Wall("images/sprites/wall.png", (obj.board[i].x*Game.scale), (obj.board[i].y*Game.scale));
								break;
							case 4:
								entities['entity'+i] = new Portal("images/sprites/portal.png", (obj.board[i].x*Game.scale), (obj.board[i].y*Game.scale));
								break;
							default:
								console.log("Error loading tile: invalid type");
						}
					}
					// Set the view on the player
					for (var i in entities) {
						if (entities[i].constructor==Player) {
							setView(entities[i]);
						}
					}
				}
			};
			xhttp.open("GET", url, true);
			xhttp.send();
		}
	}
</script>

</body>

</html>
